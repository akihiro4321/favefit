# プロジェクトワークフロー

## 指針

1. **計画が唯一の信頼できる情報源:** すべての作業は `plan.md` で追跡されなければならない
2. **技術スタックは意図的に:** 技術スタックへの変更は、実装*前*に `tech-stack.md` に文書化されなければならない
3. **テスト駆動開発:** 機能を実装する前に単体テストを書く
4. **高いコードカバレッジ:** すべてのモジュールで80%以上のコードカバレッジを目指す
5. **ユーザーエクスペリエンス第一:** すべての決定はユーザーエクスペリエンスを優先すべきである
6. **非対話的かつCI対応:** 非対話的なコマンドを優先する。監視モードのツール（テスト、リンター）には `CI=true` を使用して、一度だけの実行を保証する。

## タスクワークフロー

すべてのタスクは厳格なライフサイクルに従う：

### 標準タスクワークフロー

1. **タスク選択:** `plan.md` から次の利用可能なタスクを順番に選択する

2. **進行中としてマーク:** 作業を開始する前に、`plan.md` を編集し、タスクを `[ ]` から `[~]` に変更する

3. **失敗するテストを書く (Red フェーズ):**
   - 機能またはバグ修正のための新しいテストファイルを作成する。
   - タスクの期待される動作と受け入れ基準を明確に定義する1つ以上の単体テストを書く。
   - **重要:** テストを実行し、期待通りに失敗することを確認する。これはTDDの「Red」フェーズである。失敗するテストができるまで先に進まないこと。

4. **テストに合格するように実装する (Green フェーズ):**
   - 失敗しているテストを合格させるために必要な最小限のアプリケーションコードを書く。
   - テストスイートを再度実行し、すべてのテストが合格することを確認する。これは「Green」フェーズである。

5. **リファクタリング (推奨されるが任意):**
   - テストが合格している状態で、外部の動作を変えずに、明確さの向上、重複の排除、パフォーマンスの向上のために実装コードとテストコードをリファクタリングする。
   - リファクタリング後もテストが合格することを確認するために再実行する。

6. **カバレッジの確認:** プロジェクトで選択されたツールを使用してカバレッジレポートを実行する。例えば、Pythonプロジェクトでは以下のようになる：
   ```bash
   pytest --cov=app --cov-report=html
   ```
   目標: 新しいコードのカバレッジ >80%。特定のツールとコマンドは言語とフレームワークによって異なる。

7. **逸脱の文書化:** 実装が技術スタックと異なる場合：
   - 実装を **停止** する
   - 新しい設計で `tech-stack.md` を更新する
   - 変更を説明する日付付きのメモを追加する
   - 実装を再開する

8. **実装に対するユーザー承認を求める:**
   - 変更されたファイルとコアロジックを含む変更の概要をユーザーに提示する。
   - **一時停止** し、変更をコミットする前に明示的な承認を求める。
   - ユーザーからの明確な「はい」または承認なしにコミットステップに進まないこと。

9. **コード変更のコミット:**
   - タスクに関連するすべてのコード変更をステージングする。
   - 明確で簡潔なコミットメッセージを提案する 例: `feat(ui): Create basic HTML structure for calculator`。
   - コミットを実行する。

10. **Git Notes でタスクサマリーを添付:**
    - **ステップ 10.1: コミットハッシュの取得:** *完了したばかりのコミット* のハッシュを取得する (`git log -1 --format="%H"`)。
    - **ステップ 10.2: ノート内容のドラフト作成:** 完了したタスクの詳細なサマリーを作成する。これには、タスク名、変更の概要、作成/変更されたすべてのファイルのリスト、変更の核心的な「理由」を含めるべきである。
    - **ステップ 10.3: ノートの添付:** `git notes` コマンドを使用してサマリーをコミットに添付する。
      ```bash
      # 前のステップのノート内容は -m フラグを介して渡される。
      git notes add -m "<note content>" <commit_hash>
      ```

11. **タスクコミットSHAの取得と記録:**
    - **ステップ 11.1: 計画の更新:** `plan.md` を読み、完了したタスクの行を見つけ、ステータスを `[~]` から `[x]` に更新し、*完了したばかりのコミット* のコミットハッシュの最初の7文字を追加する。
    - **ステップ 11.2: 計画の書き込み:** 更新された内容を `plan.md` に書き込む。

12. **計画更新のコミット:**
    - **アクション:** 変更された `plan.md` ファイルをステージングする。
    - **アクション:** 説明的なメッセージでこの変更をコミットする（例: `conductor(plan): Mark task 'Create user model' as complete`）。

### フェーズ完了検証およびチェックポイントプロトコル

**トリガー:** このプロトコルは、`plan.md` 内のフェーズを終了させるタスクが完了した直後に実行される。

1.  **プロトコル開始のアナウンス:** フェーズが完了し、検証およびチェックポイントプロトコルが開始されたことをユーザーに通知する。

2.  **フェーズ変更のテストカバレッジを確保:**
    -   **ステップ 2.1: フェーズ範囲の特定:** このフェーズで変更されたファイルを特定するために、まず開始点を見つける必要がある。`plan.md` を読んで、*前の* フェーズのチェックポイントのGitコミットSHAを見つける。前のチェックポイントが存在しない場合、範囲は最初のコミット以降のすべての変更となる。
    -   **ステップ 2.2: 変更されたファイルのリスト:** `git diff --name-only <previous_checkpoint_sha> HEAD` を実行して、このフェーズ中に変更されたすべてのファイルの正確なリストを取得する。
    -   **ステップ 2.3: テストの検証と作成:** リスト内の各ファイルについて：
        -   **重要:** まず、拡張子を確認する。非コードファイル（例: `.json`, `.md`, `.yaml`）を除外する。
        -   残りの各コードファイルについて、対応するテストファイルが存在することを確認する。
        -   テストファイルが見つからない場合、作成 **しなければならない**。テストを書く前に、**まず、リポジトリ内の他のテストファイルを分析して、正しい命名規則とテストスタイルを決定する。** 新しいテストは、このフェーズのタスク（`plan.md`）で記述された機能を検証 **しなければならない**。

3.  **プロアクティブなデバッグを伴う自動テストの実行:**
    -   実行前に、テストを実行するために使用する正確なシェルコマンドをアナウンス **しなければならない**。
    -   **アナウンスの例:** "フェーズを検証するために自動テストスイートを実行します。**コマンド:** `CI=true npm test`"
    -   アナウンスされたコマンドを実行する。
    -   テストが失敗した場合、ユーザーに通知し、デバッグを開始 **しなければならない**。修正案は **最大2回** まで提案できる。2回目の修正案の後もテストが失敗する場合、**停止** し、持続的な失敗を報告し、ユーザーにガイダンスを求め **なければならない**。

4.  **詳細で実行可能な手動検証計画の提案:**
    -   **重要:** 計画を作成するために、まず `product.md`、`product-guidelines.md`、および `plan.md` を分析して、完了したフェーズのユーザー向けの目標を決定する。
    -   必要なコマンドや特定の期待される結果を含む、検証プロセスをユーザーに案内するステップバイステップの計画を作成 **しなければならない**。
    -   ユーザーに提示する計画は、以下の形式に従わ **なければならない**：

        **フロントエンドの変更の場合:**
        ```
        自動テストに合格しました。手動検証については、以下の手順に従ってください：

        **手動検証手順:**
        1.  **次のコマンドで開発サーバーを起動:** `npm run dev`
        2.  **ブラウザで次を開く:** `http://localhost:3000`
        3.  **次が表示されることを確認:** ユーザー名とメールアドレスが正しく表示された新しいユーザープロフィールページ。
        ```

        **バックエンドの変更の場合:**
        ```
        自動テストに合格しました。手動検証については、以下の手順に従ってください：

        **手動検証手順:**
        1.  **サーバーが実行されていることを確認。**
        2.  **ターミナルで次のコマンドを実行:** `curl -X POST http://localhost:8080/api/v1/users -d '{"name": "test"}'`
        3.  **次を受け取ることを確認:** ステータス `201 Created` のJSONレスポンス。
        ```

5.  **明示的なユーザーフィードバックを待つ:**
    -   詳細な計画を提示した後、ユーザーに確認を求める: "**これは期待通りですか？ はい（yes）で確認するか、変更が必要な点についてのフィードバックを提供してください。**"
    -   **一時停止** し、ユーザーの応答を待つ。明示的な「はい」または確認なしに先に進まないこと。

6.  **チェックポイントコミットの作成:**
    -   すべての変更をステージングする。このステップで変更が発生しなかった場合は、空のコミットを進める。
    -   明確で簡潔なメッセージでコミットを実行する（例: `conductor(checkpoint): Checkpoint end of Phase X`）。

7.  **Git Notes を使用した監査可能な検証レポートの添付:**
    -   **ステップ 8.1: ノート内容のドラフト作成:** 自動テストコマンド、手動検証手順、およびユーザーの確認を含む詳細な検証レポートを作成する。
    -   **ステップ 8.2: ノートの添付:** `git notes` コマンドと前のステップの完全なコミットハッシュを使用して、完全なレポートをチェックポイントコミットに添付する。

8.  **フェーズチェックポイントSHAの取得と記録:**
    -   **ステップ 7.1: コミットハッシュの取得:** *作成されたばかりのチェックポイントコミット* のハッシュを取得する (`git log -1 --format="%H"`)。
    -   **ステップ 7.2: 計画の更新:** `plan.md` を読み、完了したフェーズの見出しを見つけ、`[checkpoint: <sha>]` の形式でコミットハッシュの最初の7文字を追加する。
    -   **ステップ 7.3: 計画の書き込み:** 更新された内容を `plan.md` に書き込む。

9. **計画更新のコミット:**
    - **アクション:** 変更された `plan.md` ファイルをステージングする。
    - **アクション:** `conductor(plan): Mark phase '<PHASE NAME>' as complete` という形式に従った説明的なメッセージでこの変更をコミットする。

10.  **完了のアナウンス:** フェーズが完了し、チェックポイントが作成され、詳細な検証レポートがGit Noteとして添付されたことをユーザーに通知する。

### 品質ゲート

タスクを完了とする前に、以下を確認する：

- [ ] すべてのテストが合格している
- [ ] コードカバレッジが要件を満たしている (>80%)
- [ ] コードがプロジェクトのコードスタイルガイドラインに従っている (`code_styleguides/` で定義)
- [ ] すべてのパブリック関数/メソッドが文書化されている（例: docstrings, JSDoc, GoDoc）
- [ ] 型安全性が強制されている（例: 型ヒント, TypeScriptの型, Goの型）
- [ ] リントまたは静的解析のエラーがない（プロジェクトで設定されたツールを使用）
- [ ] モバイルで正しく動作する（該当する場合）
- [ ] 必要に応じてドキュメントが更新されている
- [ ] セキュリティの脆弱性が導入されていない

## 開発コマンド

**AIエージェントへの指示: このセクションは、プロジェクト固有の言語、フレームワーク、およびビルドツールに合わせて調整する必要がある。**

### セットアップ
```bash
# 例: 開発環境をセットアップするためのコマンド（例: 依存関係のインストール、データベースの設定）
# 例 Node.js プロジェクトの場合: npm install
# 例 Go プロジェクトの場合: go mod tidy
```

### 日々の開発
```bash
# 例: 一般的な日々のタスクのためのコマンド（例: 開発サーバーの起動、テストの実行、リント、フォーマット）
# 例 Node.js プロジェクトの場合: npm run dev, npm test, npm run lint
# 例 Go プロジェクトの場合: go run main.go, go test ./..., go fmt ./...
```

### コミット前
```bash
# 例: すべてのプレコミットチェックを実行するためのコマンド（例: フォーマット、リント、型チェック、テスト実行）
# 例 Node.js プロジェクトの場合: npm run check
# 例 Go プロジェクトの場合: make check (Makefile が存在する場合)
```

## テスト要件

### 単体テスト
- すべてのモジュールに対応するテストが必要である。
- 適切なテストセットアップ/ティアダウンメカニズムを使用する（例: fixtures, beforeEach/afterEach）。
- 外部依存関係をモックする。
- 成功ケースと失敗ケースの両方をテストする。

### 統合テスト
- 完全なユーザーフローをテストする
- データベーストランザクションを検証する
- 認証と認可をテストする
- フォーム送信を確認する

### モバイルテスト
- 可能であれば実際のiPhoneでテストする
- Safari開発者ツールを使用する
- タッチ操作をテストする
- レスポンシブレイアウトを検証する
- 3G/4Gでのパフォーマンスを確認する

## コードレビュープロセス

### セルフレビューチェックリスト
レビューを依頼する前に：

1. **機能性**
   - 機能が仕様通りに動作する
   - エッジケースが処理されている
   - エラーメッセージがユーザーフレンドリーである

2. **コード品質**
   - スタイルガイドに従っている
   - DRY原則が適用されている
   - 明確な変数/関数名
   - 適切なコメント

3. **テスト**
   - 単体テストが包括的である
   - 統合テストが合格している
   - カバレッジが十分である (>80%)

4. **セキュリティ**
   - ハードコードされたシークレットがない
   - 入力バリデーションが存在する
   - SQLインジェクションが防止されている
   - XSS保護が実施されている

5. **パフォーマンス**
   - データベースクエリが最適化されている
   - 画像が最適化されている
   - 必要に応じてキャッシングが実装されている

6. **モバイルエクスペリエンス**
   - タッチターゲットが適切である (44x44px)
   - ズームなしでテキストが読める
   - モバイルでのパフォーマンスが許容範囲内である
   - 操作感がネイティブに近い

## コミットガイドライン

### メッセージ形式
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

### タイプ
- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみ
- `style`: フォーマット、セミコロンの欠落など
- `refactor`: バグ修正も機能追加も行わないコード変更
- `test`: 欠落しているテストの追加
- `chore`: メンテナンス作業

### 例
```bash
git commit -m "feat(auth): Add remember me functionality"
git commit -m "fix(posts): Correct excerpt generation for short posts"
git commit -m "test(comments): Add tests for emoji reaction limits"
git commit -m "style(mobile): Improve button touch targets"
```

## 完了の定義

タスクは以下の時点で完了となる：

1. すべてのコードが仕様通りに実装されている
2. 単体テストが書かれ、合格している
3. コードカバレッジがプロジェクトの要件を満たしている
4. ドキュメントが完了している（該当する場合）
5. コードが設定されたすべてのリンティングおよび静的解析チェックに合格している
6. モバイルで美しく動作する（該当する場合）
7. 実装メモが `plan.md` に追加されている
8. 適切なメッセージで変更がコミットされている
9. タスクサマリーを含むGit Noteがコミットに添付されている

## 緊急手順

### 本番環境での重大なバグ
1. mainからホットフィックスブランチを作成する
2. バグの失敗するテストを書く
3. 最小限の修正を実装する
4. モバイルを含めて徹底的にテストする
5. 即座にデプロイする
6. plan.md に文書化する

### データ損失
1. すべての書き込み操作を停止する
2. 最新のバックアップから復元する
3. データの整合性を検証する
4. インシデントを文書化する
5. バックアップ手順を更新する

### セキュリティ侵害
1. すべてのシークレットを即座にローテーションする
2. アクセスログを確認する
3. 脆弱性にパッチを適用する
4. 影響を受けたユーザーに通知する（もしあれば）
5. セキュリティ手順を文書化し更新する

## デプロイメントワークフロー

### デプロイ前チェックリスト
- [ ] すべてのテストが合格している
- [ ] カバレッジ >80%
- [ ] リントエラーがない
- [ ] モバイルテストが完了している
- [ ] 環境変数が設定されている
- [ ] データベースマイグレーションの準備ができている
- [ ] バックアップが作成されている

### デプロイ手順
1. 機能ブランチをmainにマージする
2. バージョンでリリースにタグを付ける
3. デプロイメントサービスにプッシュする
4. データベースマイグレーションを実行する
5. デプロイメントを検証する
6. クリティカルパスをテストする
7. エラーを監視する

### デプロイ後
1. アナリティクスを監視する
2. エラーログを確認する
3. ユーザーフィードバックを収集する
4. 次のイテレーションを計画する

## 継続的改善

- 毎週ワークフローを見直す
- 問題点に基づいて更新する
- 学んだ教訓を文書化する
- ユーザーの幸福のために最適化する
- シンプルで保守しやすい状態を保つ